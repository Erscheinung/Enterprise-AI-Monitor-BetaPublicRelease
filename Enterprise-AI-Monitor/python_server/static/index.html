<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise AI Monitor | ML-Powered Monitoring Platform</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <style>
        :root {
            --primary-color: #3f51b5;
            --secondary-color: #f50057;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
            --info-color: #00bcd4;
            --light-color: #f8f9fa;
            --dark-color: #212529;
        }
        
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', Oxygen, Ubuntu, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f7fa;
            color: #333;
        }
        
        .dashboard-container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .card {
            margin-bottom: 24px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            border: none;
            border-radius: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .card-header {
            font-weight: 600;
            font-size: 1.05rem;
            border-bottom: 1px solid rgba(0,0,0,0.08);
            background-color: white;
            padding: 16px 20px;
            border-top-left-radius: 10px !important;
            border-top-right-radius: 10px !important;
        }
        
        .card-header-accent {
            border-top: 4px solid var(--primary-color);
        }
        
        .card-header-security {
            border-top: 4px solid var(--danger-color);
        }
        
        .card-header-infrastructure {
            border-top: 4px solid var(--info-color);
        }
        
        .card-header-business {
            border-top: 4px solid var(--warning-color);
        }
        
        .card-body {
            padding: 20px;
        }
        
        .chart-container {
            height: 300px;
            position: relative;
            padding: 10px;
        }
        
        .dashboard-header {
            padding: 30px 0 20px 0;
            position: relative;
            margin-bottom: 30px;
        }
        
        .dashboard-header::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(to right, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
        }
        
        .dashboard-title {
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 8px;
        }
        
        .dashboard-subtitle {
            color: #666;
            font-weight: 400;
            font-size: 1.1rem;
        }
        
        .status-badge {
            font-size: 0.95rem;
            padding: 8px 14px;
            border-radius: 30px;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            display: inline-block;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .status-indicator.active {
            background-color: var(--success-color);
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
        }
        
        .status-indicator.loading {
            background-color: var(--warning-color);
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.2);
        }
        
        .status-indicator.offline {
            background-color: var(--danger-color);
            box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.2);
        }
        
        .model-status {
            display: inline-flex;
            align-items: center;
            margin-right: 15px;
        }
        
        .model-status-label {
            font-weight: 500;
            margin-right: 6px;
        }
        
        .insight-item {
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.04);
            border-left: 4px solid var(--primary-color);
            font-size: 0.95rem;
            display: flex;
            align-items: center;
        }
        
        .insight-item i {
            margin-right: 10px;
            font-size: 1.2rem;
        }
        
        .critical {
            border-left-color: var(--danger-color);
        }
        
        .critical i {
            color: var(--danger-color);
        }
        
        .warning {
            border-left-color: var(--warning-color);
        }
        
        .warning i {
            color: var(--warning-color);
        }
        
        .success {
            border-left-color: var(--success-color);
        }
        
        .success i {
            color: var(--success-color);
        }
        
        .info {
            border-left-color: var(--info-color);
        }
        
        .info i {
            color: var(--info-color);
        }
        
        .recommendation {
            background-color: rgba(63, 81, 181, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border: 1px solid rgba(63, 81, 181, 0.1);
        }
        
        .recommendation h5 {
            color: var(--primary-color);
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .recommendation h5 i {
            margin-right: 8px;
        }
        
        .recent-actions {
            height: 300px;
            overflow-y: auto;
            scrollbar-width: thin;
        }
        
        .recent-actions::-webkit-scrollbar {
            width: 6px;
        }
        
        .recent-actions::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .recent-actions::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 3px;
        }
        
        .recent-actions::-webkit-scrollbar-thumb:hover {
            background: #ccc;
        }
        
        .table thead {
            background-color: rgba(0,0,0,0.02);
        }
        
        .table thead th {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.5px;
            color: #666;
            padding: 12px;
        }
        
        .action-tag {
            display: inline-block;
            padding: 4px 8px;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .action-tag.increase {
            background-color: rgba(76, 175, 80, 0.1);
            color: #388e3c;
        }
        
        .action-tag.decrease {
            background-color: rgba(244, 67, 54, 0.1);
            color: #d32f2f;
        }
        
        .action-tag.maintain {
            background-color: rgba(63, 81, 181, 0.1);
            color: #3949ab;
        }
        
        .action-tag.enhance {
            background-color: rgba(0, 188, 212, 0.1);
            color: #0097a7;
        }
        
        .action-tag.optimize {
            background-color: rgba(255, 152, 0, 0.1);
            color: #f57c00;
        }
        
        .btn-control {
            border-radius: 50px;
            padding: 8px 16px;
            font-weight: 500;
        }
        
        .form-switch .form-check-input {
            width: 3em;
            height: 1.5em;
        }
        
        .form-check-label {
            margin-left: 8px;
            font-weight: 500;
        }
        
        @media (max-width: 768px) {
            .card-header {
                font-size: 1rem;
                padding: 15px;
            }
            
            .chart-container {
                height: 250px;
            }
            
            .dashboard-header {
                padding: 20px 0 15px 0;
                margin-bottom: 20px;
            }
            
            .insight-item {
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="dashboard-header">
            <h1 class="dashboard-title text-center">Enterprise AI Monitor</h1>
            <p class="dashboard-subtitle text-center">Unified ML-powered monitoring for network security, infrastructure, and business processes</p>
        </div>
        
        <!-- Control Panel Card -->
        <div class="card mb-4">
            <div class="card-header card-header-accent d-flex justify-content-between align-items-center">
                <span><i class="bi bi-speedometer2 me-2"></i>System Control Panel</span>
                <div class="form-check form-switch d-flex align-items-center">
                    <input class="form-check-input" type="checkbox" id="live-update-switch" checked>
                    <label class="form-check-label" for="live-update-switch">Live Updates</label>
                </div>
            </div>
            <div class="card-body">
                <div class="row align-items-center">
                    <div class="col-md-6">
                        <div class="d-flex align-items-center mb-3">
                            <h5 class="mb-0 me-3">Status:</h5>
                            <span id="status-badge" class="badge bg-secondary status-badge">Initializing...</span>
                        </div>
                        <div class="d-flex flex-wrap">
                            <div class="model-status">
                                <span class="model-status-label">LSTM:</span>
                                <span class="badge bg-light text-dark" id="lstm-status"><span class="status-indicator loading"></span>Loading</span>
                            </div>
                            <div class="model-status">
                                <span class="model-status-label">GNN:</span>
                                <span class="badge bg-light text-dark" id="gnn-status"><span class="status-indicator loading"></span>Loading</span>
                            </div>
                            <div class="model-status">
                                <span class="model-status-label">RL Agent:</span>
                                <span class="badge bg-light text-dark" id="rl-status"><span class="status-indicator loading"></span>Loading</span>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 text-md-end mt-3 mt-md-0">
                        <button id="start-btn" class="btn btn-success btn-control me-2">
                            <i class="bi bi-play-fill me-1"></i> Start Simulation
                        </button>
                        <button id="stop-btn" class="btn btn-danger btn-control" disabled>
                            <i class="bi bi-stop-fill me-1"></i> Stop Simulation
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- AI Insights Panel -->
        <div class="card mb-4">
            <div class="card-header card-header-accent">
                <i class="bi bi-lightning-charge me-2"></i>AI-Generated Insights & Recommendations
            </div>
            <div class="card-body">
                <div id="insights-container">
                    <div class="insight-item info">
                        <i class="bi bi-hourglass-split"></i>
                        <span>Analyzing system data and waiting for simulation to start...</span>
                    </div>
                </div>
                <div class="recommendation" id="main-recommendation">
                    <h5><i class="bi bi-lightbulb"></i>Recommended Action</h5>
                    <p id="recommendation-text" class="mb-0">Waiting for sufficient data to generate intelligent recommendations...</p>
                </div>
            </div>
        </div>
        
        <!-- Charts Row 1 - Infrastructure Metrics -->
        <div class="row">
            <!-- CPU Chart -->
            <div class="col-md-6 mb-4">
                <div class="card h-100">
                    <div class="card-header card-header-infrastructure">
                        <i class="bi bi-cpu me-2"></i>CPU Utilization (%)
                    </div>
                    <div class="card-body chart-container">
                        <canvas id="cpu-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Memory Chart -->
            <div class="col-md-6 mb-4">
                <div class="card h-100">
                    <div class="card-header card-header-infrastructure">
                        <i class="bi bi-memory me-2"></i>Memory Utilization (%)
                    </div>
                    <div class="card-body chart-container">
                        <canvas id="memory-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Charts Row 2 - Security & Business -->
        <div class="row">
            <!-- Security Chart -->
            <div class="col-md-6 mb-4">
                <div class="card h-100">
                    <div class="card-header card-header-security">
                        <i class="bi bi-shield-exclamation me-2"></i>Security Threat Level (%)
                    </div>
                    <div class="card-body chart-container">
                        <canvas id="security-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Cost Chart -->
            <div class="col-md-6 mb-4">
                <div class="card h-100">
                    <div class="card-header card-header-business">
                        <i class="bi bi-cash-coin me-2"></i>Operating Costs ($)
                    </div>
                    <div class="card-body chart-container">
                        <canvas id="cost-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Recent Actions -->
        <div class="card">
            <div class="card-header card-header-accent">
                <i class="bi bi-activity me-2"></i>RL Agent Activity Log
            </div>
            <div class="card-body recent-actions p-0">
                <table class="table table-hover mb-0">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Action</th>
                            <th>Reward</th>
                            <th>System Impact</th>
                        </tr>
                    </thead>
                    <tbody id="actions-table-body">
                        <tr>
                            <td colspan="4" class="text-center py-4 text-muted">
                                <i class="bi bi-clock-history me-2"></i>No actions recorded yet - waiting for agent activity
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // API URL
        const API_URL = 'http://localhost:5000/api';
        
        // DOM elements
        const statusBadge = document.getElementById('status-badge');
        const lstmStatus = document.getElementById('lstm-status');
        const gnnStatus = document.getElementById('gnn-status');
        const rlStatus = document.getElementById('rl-status');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const actionsTableBody = document.getElementById('actions-table-body');
        const liveUpdateSwitch = document.getElementById('live-update-switch');
        const insightsContainer = document.getElementById('insights-container');
        const recommendationText = document.getElementById('recommendation-text');
        
        // Chart common configuration
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            elements: {
                line: {
                    tension: 0.2
                },
                point: {
                    radius: 2,
                    hoverRadius: 4
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(255, 255, 255, 0.9)',
                    titleColor: '#333',
                    bodyColor: '#333',
                    borderColor: 'rgba(0, 0, 0, 0.1)',
                    borderWidth: 1,
                    displayColors: false,
                    padding: 10,
                    cornerRadius: 6,
                    boxPadding: 3
                }
            },
            interaction: {
                mode: 'index',
                intersect: false
            },
            scales: {
                x: {
                    grid: {
                        display: false
                    },
                    ticks: {
                        maxRotation: 0,
                        autoSkip: true,
                        maxTicksLimit: 8
                    }
                },
                y: {
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)',
                        drawBorder: false
                    },
                    ticks: {
                        padding: 10
                    }
                }
            }
        };
        
        // CPU Chart
        const cpuChart = new Chart(document.getElementById('cpu-chart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'CPU Utilization',
                    data: [],
                    borderColor: 'rgb(0, 176, 255)',
                    backgroundColor: 'rgba(0, 176, 255, 0.1)',
                    borderWidth: 2,
                    fill: 'origin'
                }]
            },
            options: {
                ...chartOptions,
                scales: {
                    ...chartOptions.scales,
                    y: {
                        ...chartOptions.scales.y,
                        max: 100,
                        title: {
                            display: true,
                            text: 'Utilization %'
                        }
                    }
                },
                plugins: {
                    ...chartOptions.plugins,
                    annotation: {
                        annotations: {
                            dangerZone: {
                                type: 'box',
                                xScaleID: 'x',
                                yScaleID: 'y',
                                yMin: 90,
                                yMax: 100,
                                backgroundColor: 'rgba(244, 67, 54, 0.1)',
                                borderColor: 'rgba(244, 67, 54, 0.5)',
                                borderWidth: 1
                            },
                            warningZone: {
                                type: 'box',
                                xScaleID: 'x',
                                yScaleID: 'y',
                                yMin: 80,
                                yMax: 90,
                                backgroundColor: 'rgba(255, 152, 0, 0.1)',
                                borderColor: 'rgba(255, 152, 0, 0.5)',
                                borderWidth: 1
                            },
                            optimalZone: {
                                type: 'box',
                                xScaleID: 'x',
                                yScaleID: 'y',
                                yMin: 60,
                                yMax: 80,
                                backgroundColor: 'rgba(76, 175, 80, 0.1)',
                                borderColor: 'rgba(76, 175, 80, 0.5)',
                                borderWidth: 1
                            }
                        }
                    }
                }
            }
        });
        
        // Memory Chart
        const memoryChart = new Chart(document.getElementById('memory-chart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Memory Utilization',
                    data: [],
                    borderColor: 'rgb(103, 58, 183)',
                    backgroundColor: 'rgba(103, 58, 183, 0.1)',
                    borderWidth: 2,
                    fill: 'origin'
                }]
            },
            options: {
                ...chartOptions,
                scales: {
                    ...chartOptions.scales,
                    y: {
                        ...chartOptions.scales.y,
                        max: 100,
                        title: {
                            display: true,
                            text: 'Utilization %'
                        }
                    }
                },
                plugins: {
                    ...chartOptions.plugins,
                    annotation: {
                        annotations: {
                            dangerZone: {
                                type: 'box',
                                xScaleID: 'x',
                                yScaleID: 'y',
                                yMin: 90,
                                yMax: 100,
                                backgroundColor: 'rgba(244, 67, 54, 0.1)',
                                borderColor: 'rgba(244, 67, 54, 0.5)',
                                borderWidth: 1
                            },
                            warningZone: {
                                type: 'box',
                                xScaleID: 'x',
                                yScaleID: 'y',
                                yMin: 75,
                                yMax: 90,
                                backgroundColor: 'rgba(255, 152, 0, 0.1)',
                                borderColor: 'rgba(255, 152, 0, 0.5)',
                                borderWidth: 1
                            }
                        }
                    }
                }
            }
        });
        
        // Security Chart
        const securityChart = new Chart(document.getElementById('security-chart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Threat Level',
                    data: [],
                    borderColor: 'rgb(244, 67, 54)',
                    backgroundColor: 'rgba(244, 67, 54, 0.1)',
                    borderWidth: 2,
                    fill: 'origin'
                }]
            },
            options: {
                ...chartOptions,
                scales: {
                    ...chartOptions.scales,
                    y: {
                        ...chartOptions.scales.y,
                        max: 100,
                        title: {
                            display: true,
                            text: 'Threat Level %'
                        }
                    }
                },
                plugins: {
                    ...chartOptions.plugins,
                    annotation: {
                        annotations: {
                            criticalThreatZone: {
                                type: 'box',
                                xScaleID: 'x',
                                yScaleID: 'y',
                                yMin: 70,
                                yMax: 100,
                                backgroundColor: 'rgba(244, 67, 54, 0.1)',
                                borderColor: 'rgba(244, 67, 54, 0.5)',
                                borderWidth: 1
                            },
                            moderateThreatZone: {
                                type: 'box',
                                xScaleID: 'x',
                                yScaleID: 'y',
                                yMin: 30,
                                yMax: 70,
                                backgroundColor: 'rgba(255, 152, 0, 0.1)',
                                borderColor: 'rgba(255, 152, 0, 0.5)',
                                borderWidth: 1
                            }
                        }
                    }
                }
            }
        });
        
        // Cost Chart
        const costChart = new Chart(document.getElementById('cost-chart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Operating Costs',
                    data: [],
                    borderColor: 'rgb(255, 87, 34)',
                    backgroundColor: 'rgba(255, 87, 34, 0.1)',
                    borderWidth: 2,
                    fill: 'origin'
                }]
            },
            options: {
                ...chartOptions,
                scales: {
                    ...chartOptions.scales,
                    y: {
                        ...chartOptions.scales.y,
                        title: {
                            display: true,
                            text: 'Cost ($)'
                        }
                    }
                }
            }
        });
        
        // Function to format action names for display
        function formatActionName(action) {
            const actionMap = {
                'INCREASE_RESOURCES': 'Increase Resources',
                'DECREASE_RESOURCES': 'Decrease Resources',
                'MAINTAIN_RESOURCES': 'Maintain Resources',
                'ENHANCE_SECURITY': 'Enhance Security',
                'OPTIMIZE_COST': 'Optimize Cost'
            };
            
            return actionMap[action] || action;
        }
        
        // Function to get action impact description
        function getActionImpact(action) {
            switch (action) {
                case 'INCREASE_RESOURCES':
                    return 'Improved performance, increased cost';
                case 'DECREASE_RESOURCES':
                    return 'Reduced cost, potential performance impact';
                case 'MAINTAIN_RESOURCES':
                    return 'Balanced performance and cost';
                case 'ENHANCE_SECURITY':
                    return 'Improved security posture, increased resource usage';
                case 'OPTIMIZE_COST':
                    return 'Reduced operating expenses, minimal performance impact';
                default:
                    return 'Unknown impact';
            }
        }
        
        // Function to get action CSS class
        function getActionClass(action) {
            const classMap = {
                'INCREASE_RESOURCES': 'increase',
                'DECREASE_RESOURCES': 'decrease',
                'MAINTAIN_RESOURCES': 'maintain',
                'ENHANCE_SECURITY': 'enhance',
                'OPTIMIZE_COST': 'optimize'
            };
            
            return classMap[action] || '';
        }
        
        // Generate AI insights based on current data
        function generateInsights(data) {
            if (!data.cpu_utilization || data.cpu_utilization.length === 0) {
                return [];
            }
            
            const insights = [];
            const cpu = data.cpu_utilization;
            const memory = data.memory_utilization;
            const security = data.security_threats;
            const costs = data.costs;
            const actions = data.actions_taken;
            
            // Calculate current values (latest data point)
            const currentCpu = cpu[cpu.length - 1] * 100;
            const currentMemory = memory[memory.length - 1] * 100;
            const currentSecurity = security[security.length - 1] * 100;
            const currentCost = costs[costs.length - 1];
            
            // Calculate trends (average of last 5 points vs previous 5)
            const cpuTrend = calculateTrend(cpu, 5);
            const memoryTrend = calculateTrend(memory, 5);
            const securityTrend = calculateTrend(security, 5);
            const costTrend = calculateTrend(costs, 5);
            
            // CPU insights
            if (currentCpu > 90) {
                insights.push({
                    type: 'critical',
                    icon: 'bi-exclamation-triangle-fill',
                    message: `Critical CPU utilization (${currentCpu.toFixed(1)}%) detected - system at risk of performance degradation`
                });
            } else if (currentCpu > 80) {
                insights.push({
                    type: 'warning',
                    icon: 'bi-exclamation-circle',
                    message: `High CPU utilization (${currentCpu.toFixed(1)}%) - consider scaling resources`
                });
            } else if (cpuTrend > 5) {
                insights.push({
                    type: 'warning',
                    icon: 'bi-graph-up-arrow',
                    message: `CPU utilization increasing rapidly (+${cpuTrend.toFixed(1)}%) - monitor closely`
                });
            } else if (currentCpu < 30 && actions.length > 5) {
                insights.push({
                    type: 'info',
                    icon: 'bi-info-circle',
                    message: `CPU utilization is unusually low (${currentCpu.toFixed(1)}%) - resources may be overprovisioned`
                });
            }
            
            // Memory insights
            if (currentMemory > 90) {
                insights.push({
                    type: 'critical',
                    icon: 'bi-exclamation-triangle-fill',
                    message: `Critical memory utilization (${currentMemory.toFixed(1)}%) - system at risk of OOM errors`
                });
            } else if (memoryTrend > 5) {
                insights.push({
                    type: 'warning',
                    icon: 'bi-graph-up-arrow',
                    message: `Memory usage increasing rapidly (+${memoryTrend.toFixed(1)}%) - potential memory leak`
                });
            }
            
            // Security insights
            if (currentSecurity > 70) {
                insights.push({
                    type: 'critical',
                    icon: 'bi-shield-exclamation',
                    message: `High security threat level (${currentSecurity.toFixed(1)}%) - immediate investigation required`
                });
            } else if (currentSecurity > 50) {
                insights.push({
                    type: 'warning',
                    icon: 'bi-shield-fill-exclamation',
                    message: `Elevated security threats (${currentSecurity.toFixed(1)}%) detected - review security logs`
                });
            } else if (securityTrend > 5) {
                insights.push({
                    type: 'warning',
                    icon: 'bi-graph-up-arrow',
                    message: `Security threats increasing (+${securityTrend.toFixed(1)}%) - monitor network activity`
                });
            }
            
            // Cost insights
            if (costTrend > 10) {
                insights.push({
                    type: 'warning',
                    icon: 'bi-cash',
                    message: `Operating costs rising rapidly (+$${costTrend.toFixed(2)}) - review resource allocation`
                });
            } else if (costTrend < -10) {
                insights.push({
                    type: 'success',
                    icon: 'bi-check-circle',
                    message: `Cost optimization effective (-$${Math.abs(costTrend).toFixed(2)}) - maintaining current strategy recommended`
                });
            }
            
            // Action correlation insights
            if (actions.length > 5) {
                const lastAction = actions[actions.length - 1];
                const lastActionTime = new Date(data.timestamps[data.timestamps.length - 1] * 1000).toLocaleTimeString();
                
                if (lastAction === 'ENHANCE_SECURITY' && securityTrend < -5) {
                    insights.push({
                        type: 'success',
                        icon: 'bi-shield-check',
                        message: `Security enhancement at ${lastActionTime} effectively reduced threat levels by ${Math.abs(securityTrend).toFixed(1)}%`
                    });
                } else if (lastAction === 'OPTIMIZE_COST' && costTrend < -5) {
                    insights.push({
                        type: 'success',
                        icon: 'bi-piggy-bank',
                        message: `Cost optimization at ${lastActionTime} reduced operating costs by $${Math.abs(costTrend).toFixed(2)}`
                    });
                }
            }
            
            // Add balanced recommendation
            let recommendation = "";
            
            if (currentCpu > 85 && currentSecurity < 50) {
                recommendation = "Increase computing resources to handle high CPU load, while maintaining current security measures.";
            } else if (currentSecurity > 60) {
                recommendation = "Prioritize security enhancements to address elevated threat levels. Consider temporarily increasing resources to support additional security monitoring.";
            } else if (currentCpu < 40 && currentCost > 120) {
                recommendation = "Optimize costs by reducing provisioned resources. Current utilization indicates overprovisioning.";
            } else if (currentCpu > 75 && currentCost > 150) {
                recommendation = "Consider a balanced approach: scale resources carefully while implementing targeted cost optimization measures.";
            } else {
                recommendation = "System operating within normal parameters. Maintain current resource allocation and security measures.";
            }
            
            recommendationText.textContent = recommendation;
            
            return insights;
        }
        
        // Calculate trend (change between periods)
        function calculateTrend(dataArray, lookback = 5) {
            if (dataArray.length < lookback * 2) return 0;
            
            const current = dataArray.slice(-lookback);
            const previous = dataArray.slice(-lookback * 2, -lookback);
            
            const currentAvg = current.reduce((sum, val) => sum + val, 0) / current.length;
            const previousAvg = previous.reduce((sum, val) => sum + val, 0) / previous.length;
            
            // For percentage values (CPU, memory, security)
            if (currentAvg <= 1 && previousAvg <= 1) {
                return (currentAvg - previousAvg) * 100; // Convert to percentage points
            }
            
            // For absolute values (cost)
            return currentAvg - previousAvg;
        }
        
        // Update insights panel
        function updateInsightsPanel(insights) {
            // Clear container
            insightsContainer.innerHTML = '';
            
            if (insights.length === 0) {
                insightsContainer.innerHTML = `
                    <div class="insight-item info">
                        <i class="bi bi-info-circle"></i>
                        <span>Monitoring system metrics. No significant insights detected yet.</span>
                    </div>
                `;
                return;
            }
            
            // Add each insight
            insights.forEach(insight => {
                const insightElement = document.createElement('div');
                insightElement.className = `insight-item ${insight.type}`;
                insightElement.innerHTML = `<i class="bi ${insight.icon}"></i><span>${insight.message}</span>`;
                insightsContainer.appendChild(insightElement);
            });
        }
        
        // Update model status indicators
        function updateModelStatus(element, isLoaded) {
            if (isLoaded) {
                element.innerHTML = '<span class="status-indicator active"></span>Active';
                element.className = 'badge bg-light text-success';
            } else {
                element.innerHTML = '<span class="status-indicator offline"></span>Offline';
                element.className = 'badge bg-light text-danger';
            }
        }
        
        // Start simulation
        startBtn.addEventListener('click', async () => {
            try {
                startBtn.disabled = true;
                startBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Starting...';
                
                const response = await fetch(`${API_URL}/start-simulation`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.status === 'success') {
                    statusBadge.textContent = 'Running';
                    statusBadge.className = 'badge bg-success status-badge';
                    startBtn.disabled = true;
                    startBtn.innerHTML = '<i class="bi bi-play-fill me-1"></i> Start Simulation';
                    stopBtn.disabled = false;
                } else {
                    alert('Failed to start simulation: ' + data.message);
                    startBtn.disabled = false;
                    startBtn.innerHTML = '<i class="bi bi-play-fill me-1"></i> Start Simulation';
                }
            } catch (error) {
                console.error('Error starting simulation:', error);
                alert('Failed to start simulation: ' + error.message);
                startBtn.disabled = false;
                startBtn.innerHTML = '<i class="bi bi-play-fill me-1"></i> Start Simulation';
            }
        });
        
        // Stop simulation
        stopBtn.addEventListener('click', async () => {
            try {
                stopBtn.disabled = true;
                stopBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Stopping...';
                
                const response = await fetch(`${API_URL}/stop-simulation`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.status === 'success') {
                    statusBadge.textContent = 'Stopped';
                    statusBadge.className = 'badge bg-danger status-badge';
                    stopBtn.disabled = true;
                    stopBtn.innerHTML = '<i class="bi bi-stop-fill me-1"></i> Stop Simulation';
                    startBtn.disabled = false;
                } else {
                    alert('Failed to stop simulation: ' + data.message);
                    stopBtn.disabled = false;
                    stopBtn.innerHTML = '<i class="bi bi-stop-fill me-1"></i> Stop Simulation';
                }
            } catch (error) {
                console.error('Error stopping simulation:', error);
                alert('Failed to stop simulation: ' + error.message);
                stopBtn.disabled = false;
                stopBtn.innerHTML = '<i class="bi bi-stop-fill me-1"></i> Stop Simulation';
            }
        });
        
        // Update dashboard with latest data
        async function updateDashboard() {
            if (!liveUpdateSwitch.checked) return;
            
            try {
                // Get status
                const statusResponse = await fetch(`${API_URL}/status`);
                const statusData = await statusResponse.json();
                
                // Update status indicators
                if (statusData.status === 'running') {
                    statusBadge.textContent = 'Running';
                    statusBadge.className = 'badge bg-success status-badge';
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                } else {
                    statusBadge.textContent = 'Stopped';
                    statusBadge.className = 'badge bg-danger status-badge';
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                }
                
                updateModelStatus(lstmStatus, statusData.models_loaded.lstm);
                updateModelStatus(gnnStatus, true); // Assuming GNN is loaded if server is running
                updateModelStatus(rlStatus, statusData.models_loaded.rl_agent);
                
                // Get simulation data if running
                if (statusData.status === 'running') {
                    const dataResponse = await fetch(`${API_URL}/simulation-data`);
                    const simulationData = await dataResponse.json();
                    
                    // Update charts
                    updateCharts(simulationData);
                    
                    // Update recent actions table
                    updateActionsTable(simulationData);
                    
                    // Generate and update AI insights
                    const insights = generateInsights(simulationData);
                    updateInsightsPanel(insights);
                }
            } catch (error) {
                console.error('Error updating dashboard:', error);
            }
        }
        
        // Update charts with new data
        function updateCharts(data) {
            if (!data.timestamps || data.timestamps.length === 0) return;
            
            // Format times
            const times = data.timestamps.map(timestamp => 
                new Date(timestamp * 1000).toLocaleTimeString()
            );
            
            // Limit data points to improve performance
            const maxPoints = 60;
            const startIdx = Math.max(0, times.length - maxPoints);
            
            const limitedTimes = times.slice(startIdx);
            
            // Update CPU chart
            cpuChart.data.labels = limitedTimes;
            cpuChart.data.datasets[0].data = data.cpu_utilization.slice(startIdx).map(val => val * 100);
            cpuChart.update();
            
            // Update memory chart
            memoryChart.data.labels = limitedTimes;
            memoryChart.data.datasets[0].data = data.memory_utilization.slice(startIdx).map(val => val * 100);
            memoryChart.update();
            
            // Update security chart
            securityChart.data.labels = limitedTimes;
            securityChart.data.datasets[0].data = data.security_threats.slice(startIdx).map(val => val * 100);
            securityChart.update();
            
            // Update cost chart
            costChart.data.labels = limitedTimes;
            costChart.data.datasets[0].data = data.costs.slice(startIdx);
            costChart.update();
        }
        
        // Update recent actions table
        function updateActionsTable(data) {
            if (!data.actions_taken || data.actions_taken.length === 0) return;
            
            // Get the most recent actions (up to 10)
            const length = data.actions_taken.length;
            const start = Math.max(0, length - 10);
            
            const recentActions = [];
            for (let i = length - 1; i >= start; i--) {
                recentActions.push({
                    time: new Date(data.timestamps[i] * 1000).toLocaleTimeString(),
                    action: data.actions_taken[i],
                    reward: data.rewards[i]
                });
            }
            
            // Update table
            actionsTableBody.innerHTML = recentActions.map(item => {
                const actionClass = getActionClass(item.action);
                return `
                <tr>
                    <td>${item.time}</td>
                    <td><span class="action-tag ${actionClass}">${formatActionName(item.action)}</span></td>
                    <td class="${item.reward >= 0 ? 'text-success' : 'text-danger'} fw-bold">
                        ${item.reward >= 0 ? '+' : ''}${item.reward.toFixed(2)}
                    </td>
                    <td>${getActionImpact(item.action)}</td>
                </tr>
            `}).join('');
        }
        
        // Initial update and set interval for continuous updates
        updateDashboard();
        setInterval(updateDashboard, 1000);
    </script>
</body>
</html>